ニューラルネットワークにおけるノードの確率的2値モデルのプログラム作成
====================


#### 概要

入力X,Y,ZについてX=3,Y=2,Z=-1の重み付けを行い、閾値θ=1で動作する確率的2値モデルのプログラムを作成し、入力X,Y,Zが(1,1,0)、(1,ｰ1,0)、(0,1,0)の場合、出力1となる頻度が理論値通りになるかを検証する。入力値の評価にはシグモイド関数を用いる。

##### 使用環境

- Node.js v0.8.9
- TypeScript 0.8.0
- Ruby 1.9.3
- Python 3.2

### 理論値の算出

入力値の評価にシグモイド関数を利用するので、出力1となる頻度の理論値は入力値をシグモイド関数に入力した場合の戻り値に等しい。シグモイド関数のゲインa=1の場合のおおよその理論値は次のようになる。

入力       | 出力
-----------|-----:
(1, 1, 0)  | 0.982
(1, -1, 0) | 0.500
(0, 1, 0)  | 0.731

### プログラムの作成

プログラムはJavaScript、Ruby、Python、TypeScriptでそれぞれ実装する。

### 実行

各言語での実行結果は次のようになった。(N=1000000)

言語 \ 入力 | (1, 1, 0)  | (1, ｰ1, 0)  | (0, 1, 0)
------------|-----------:|------------:|------------:
JavaScript  |   0.982146 |    0.501182 | 0.731039
TypeScript  |   0.981932 |    0.500593 | 0.730958
Ruby        |   0.982072 |    0.500515 | 0.730827
Python      |   0.981791 |    0.500203 | 0.730784

### 考察・感想

##### 実行時間

性能についてほとんど考慮しない実装での実行時間を測ってみたところ、おおよそ次のような結果になった(計測にはUnixコマンドのtimeを使用)。

- JavaScript: 2.31s
- TypeScript: 2.31s
- Ruby: 5.26s
- Python: 8.04s

##### 関数型言語的アプローチと実行時間

リスト内包表記やzip,map関数の使用など、関数型言語で積極的に取り入れられている方法を用いた場合と、従来の方法を用いた場合の実行速度をPythonとRubyでそれぞれ測ってみたところ、従来の方法を用いた方が2秒ほど速かった。よって、今回のような単純で何度も繰り返し実行されるプログラムの場合には、関数型言語的なコードを書くよりも単純なforループなどを用いるコードを書いた方がいいと分かった。

##### 各言語での関数の取り扱い

###### JavaScript, TypeScript

コンテキスト(this)の変化に注意しなければならない。JavaScriptの関数は、オブジェクトのメソッドとして呼び出された場合と、関数として呼び出された場合でコンテキストの値が異なるので、想定外の変数割り当てなどを防ぐためにコンテキストの値に注意する必要がある。特にコールバック関数を設定しようとする場合に問題が起きやすい。対策として、(1) thisの値を適当な変数(thatやcontextなど)へ束縛しておき、クロージャとしてその変数にアクセスする、(2) (1)と`Funciton#apply()`を利用してコンテキストを任意に設定して実行するproxy関数を作る(`jQuery.proxy()`等)、(3) ECMAScript 6の`Proxy`を用いる、などがある。

###### Ruby

Rubyには関数的なオブジェクトとしてProc(ブロックをオブジェクト化したようなもの)とLambda(より関数的な振る舞いをするオブジェクト)がある。主な場合はLambdaが使われる。関数呼び出しには()ではなく[]を用いる、関数呼び出しの括弧を省略できない、など、メソッドとは少しインタフェースが異なるところに注意しなければならない。

###### Python

メソッドは、第一引数にレシーバーオブジェクト(self)を部分適用した関数として表される。クラス定義時以外などでオブジェクトにメソッドを追加したい場合は`MethodType()`を用いて関数をバインド/アンバインドする必要がある。もしバインド/アンバインドしなかった場合、関数はレシーバーオブジェクトを受け取らない。